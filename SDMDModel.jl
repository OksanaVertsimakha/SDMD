using Pkg
using Random, Distributions, DataFrames, StatsBase, CairoMakie, ProgressMeter, PrettyTables, JLD2, Integrals



# Core model elements
# Mating model
function Mating(; Nf, Nm, E, ff, r_sex, beta=0, M2=10, M=4)
    N_pairs_A = zeros(Int64, M2, M2)
    N_pairs_Af = zeros(Int64, M2, M2)
    
    Nm_sum = sum(Nm)
    pAm = ifelse(Nm_sum > 0, Nm / Nm_sum, fill(1 / M2, M2))  # Avoid division by zero
    p_beta = Nm_sum / (beta + Nm_sum)

    N_exp_f = zeros(Int64, M2)
    N_exp_m = zeros(Int64, M2)

    multinomial_dist = [Multinomial(round(Int64, Nf[i] * p_beta), pAm) for i in 1:M2]

    # Sample number of mating pairs for each genotype combination
    for i in 1:M2
        rand!(multinomial_dist[i], view(N_pairs_A, i, :))
    end

    poisson_samples = Vector{Poisson}(undef, M2)
    for j in 1:M2
        for i in 1:M2
            poisson_samples[i] = Poisson(N_pairs_A[i, j] * ff[i,j])
            N_pairs_Af[i, j] = rand(poisson_samples[i])  # Sample once, reusing distribution
        end
    end

    # Sample offspring production  # i is the females, j is the males
    for j in 1:M2
        for i in 1:M2
            if N_pairs_Af[i, j] > 0
                N_exp = rand(Multinomial(N_pairs_Af[i, j], E[i][j]))  # Offspring count
                N_sx = rand.(Binomial.(N_exp, 1 .- r_sex[j, i]))  # Sex allocation 

                @inbounds N_exp_f .+= N_sx
                @inbounds N_exp_m .+= (N_exp .- N_sx)
            end
        end
    end

    return N_exp_f, N_exp_m
end

# Fitness change: survival/sterility effects in adults
Fitness_change = function (; Nf, Nm, wf, wm, M2=10)
    Nf_new = first.(rand.(Binomial.(Nf, wf), 1))
    Nm_new = first.(rand.(Binomial.(Nm, wm), 1))
    return Nf_new, Nm_new
end
#Density-dependent mortality
Ddm_change = function (; Nf, Nm, Nh, alpha, M2=10)
    p = alpha / (Nh + alpha)
    Nf_new = first.(rand.(Binomial.(Nf, p), 1))
    Nm_new = first.(rand.(Binomial.(Nm, p), 1))
    return Nf_new, Nm_new
end

# Model for 1 generational change
# Ntfi/Ntmi for total adult population, Ntf/Ntm for fertile adult population, counted per genotype
Model2 = function (; Nf, Nm, E, wm, wf, alpha::Int64=10^6, ff, r_sex=0.5, beta=1, M2=10, M=4)
    Nf, Nm = Mating(; Nf=Nf, Nm=Nm, E=E, ff=ff, r_sex=r_sex, beta=beta, M2=M2, M=M)
    Nh = sum(Nf .+ Nm)
    Nf_1, Nm_1 = Ddm_change(; Nf=Nf, Nm=Nm, Nh=Nh, alpha=alpha, M2=M2)[1:2]
    Nf_2, Nm_2 = Fitness_change(; Nf=Nf_1, Nm=Nm_1, wf=wf, wm=wm, M2=M2)
    df = DataFrame(Ntf=Nf_2, Ntm=Nm_2, Ntfi=Nf_1, Ntmi=Nm_1)
    return df
end

# Population size input
Input_nosp = function (; M=4, Nmean=10^5, pm=0.01)
    M2 = Int(M * (M + 1) / 2)
    Ntf_init = zeros(M2)
    Ntf_init[1] = Int64(round(Nmean / 2))
    Ntm_init = zeros(M2)
    Ntm_init[1] = Int64(round(Nmean / 2))
    Ntm_init[M+1] = ceil(Int64, Ntm_init[1] * pm)
    Ntm_init[1] = ceil(Int64, Ntm_init[1] * (1 - pm))
    return Ntf_init, Ntm_init
end

# Full simulations over time. Tracking only cumulative population size by sex
# Parameters: maxgen=number of generations
# N=total effective population size
# beta=parameter of probability of successfully finding a male mate in small population
#      e.g., p=(number of males)/(number of males+beta). Not used in non-spatial modelling
# wmf=fitness and reproduction data, generated by Fitness_input1 function
# e=gametes production data,  generated by E_Make_1 function
# alpha=parameter related to density depending mortality. Alpha=0 for equilibrium = N
# M=4 or M=5 = number of alleles (M=5 for drive with no sex distorter)
#pm = initial DD drive males release frequency
function Model_nosp_NT(; N=10^15, pm=0.01, wmf,e, mD_sex, beta=0, alpha=0, maxgen=10, M=4)
    Ntf_init, Ntm_init = Input_nosp(; M=M, Nmean=N, pm=pm)
   
    M2 = Int(M * (M + 1) / 2)
    f=wmf[3][1,1]
    alpha = alpha == 0 ? round(Int64, f * N / (f / 2 - 1) / 2) : alpha

    r_sex = 0.5 .* ones(M2, M2)
    if M == 4
        for i in [2, 5, 6, 7]
            r_sex[i, :] .= mD_sex
        end
    end
    if M == 5
        for i in [2, 6, 7, 8, 9]
            r_sex[i, :] .= mD_sex
        end
    end

    model=Model2

    NCountF=Array{Int128}(undef, maxgen)
    NCountM=Array{Int128}(undef, maxgen)

    
    Ntf, Ntm = copy(Ntf_init), copy(Ntm_init)
    Ntfi, Ntmi = copy(Ntf_init), copy(Ntm_init)
    NCountF[1]=sum(Ntf_init)
    NCountM[1]=sum(Ntm_init)

    for gen in 1:(maxgen - 1)
        # Reproduction change
       
        if (NCountM[gen]>1) * (NCountF[gen]>1)> 0
            beta = NCountM[gen] / (NCountM[gen] + beta)
            m = model(; Nf=Ntf, Nm=Ntm, E=e, alpha=alpha, ff=wmf[3], wm=wmf[1], wf=wmf[2], r_sex=r_sex, beta=beta, M2=M2, M=M)
            Ntf = m.Ntf
            Ntm = m.Ntm
            Ntfi = m.Ntfi
            Ntmi = m.Ntmi
            
        else
            Ntf, Ntm, Ntfi, Ntmi = zeros(Int64, M2), zeros(Int64, M2), zeros(Int64, M2), zeros(Int64, M2)
        end
        NCountM[gen+1] = sum(Ntm)
        NCountF[gen+1] = sum(Ntf)
    end
    return [NCountF, NCountM]
end


#Additional functions
Genot=function(;A,M2,M)
    v = Array{Float64}(undef,M2)
    k=0
    for i in 1:M
        v[k+=1] =A[i,i]
        for j in (i+1):M
            v[k+=1]=A[i,j]+A[j,i]
        end
    end
    return v
end

# Gametes produced probability (genotype) 
E_Make_1=function(;c=0.95,j=0.03,a=0.01,b=0.001,show=false,M=4,title="Gametes produces")
    if M==5
        E5=vcat(
            [1 0 0 0 0],
            [(1-c)/2 (1/2+c*(1-j)*(1-a)/2) c*j*(1-b)/2 c*j*b/2 c*(1-j)*a/2],
            [1/2 0 1/2 0 0],
            [1/2 0 0 1/2 0],
            [(1-c)/2 0 c*j*(1-b)/2 c*j*b/2 (1/2+c*(1-j)/2)],
            [0 1 0 0 0],
            [0 1/2 1/2 0 0],
            [0 1/2 0 1/2 0],
            [0 1/2 0 0 1/2],
            [0 0 1 0 0],
            [0 0 1/2 1/2 0],
            [0 0 1/2 0 1/2],
            [0 0 0 1 0],
            [0 0 0 1/2 1/2],
            [0 0 0 0 1]
            )
        if show 
            namesG=["WW","WD","WN","WR","WO","DD","DN","DR","DO","NN","NR","NO", "RR","RO","OO"]
            namesA=["W","D","N","R","O"]
            hl_odd = Highlighter( f   = (data,i,j) -> i in [2,6,7,8,9],
                             crayon = Crayon(background = :light_blue))
            pretty_table(E5,header=namesA,tf=tf_borderless,row_labels=namesG,highlighters=hl_odd,title=title)
        end
    end
    if M==4
        E5=vcat(
            [1 0 0 0 ],
            [(1-c)/2 (1/2+c*(1-j)/2) c*j*(1-b)/2 c*j*b/2 ],
            [1/2 0 1/2 0 ],
            [1/2 0 0 1/2 ],
            [0 1 0 0 ],
            [0 1/2 1/2 0 ],
            [0 1/2 0 1/2 ],
            [0 0 1 0 ],
            [0 0 1/2 1/2 ],
            [0 0 0 1 ]
            )
        if show 
            namesG=["WW","WD","WN","WR","DD","DN","DR","NN","NR", "RR"]
            namesA=["W","D","N","R"]
            hl_odd = Highlighter( f   = (data,i,j) -> i in [2,5,6,7],
                                  crayon = Crayon(background = :light_blue))
            pretty_table(E5,header=namesA,tf=tf_borderless,row_labels=namesG,highlighters=hl_odd,title=title)

        end
    end    
    return transpose(E5)
end
# Gametes produced probability (sex-specific homing)

# f x m gametes pairs produced by each genotype pair
E_mat=function(;Ef,Em,M2,M)
    E_temp=[[Ef[:,i]*transpose(Em[:,j]) for i in 1:M2] for j in 1:M2]
    e=[[Genot(;A=E_temp[i][j],M=M,M2=M2) for i in 1:M2] for j in 1:M2]
    return e
end

# gametes production final function. Allows for homing in female/males/both
E_Make = function (; M=4, homing=:b, c_m=0.9, j_m=035, a_m=0, b_m=0.001, c_f=0.9, j_f=0.035, a_f=0, b_f=0.001, show=false)
    M2 =Int(M*(M+1)/2)
    if homing == :b
        if show
            println("Homing in both sexes")
        end
        Em = E_Make_1(; c=c_m, j=j_m, a=a_m, b=b_m, show=show, M=M, title="Gametes produced (males)")
        Ef = E_Make_1(; c=c_f, j=j_f, a=a_f, b=b_f, show=show, M=M, title="Gametes produced (females)")
    elseif homing == :m
        if show
            println("Homing in males")
        end
        Em = E_Make_1(; c=c_m, j=j_m, a=a_m, b=b_m, show=show, M=M, title="Gametes produced (males)")
        Ef = E_Make_1(; c=0, j=0, a=0, b=0, show=false, M=M, title="Gametes produced (females)")
    elseif homing == :f
        if show
            println("Homing in females")
        end
        Em = E_Make_1(; c=0, j=0, a=0, b=0, show=false, M=M, title="Gametes produced (males)")
        Ef = E_Make_1(; c=c_f, j=j_f, a=a_f, b=b_f, show=show, M=M, title="Gametes produced (females)")
    end
    e = E_mat(; Ef=Ef, Em=Em, M2=M2, M=M)
    return e
end

Fitness_input1=function(;sigma=0.02,s=1,h=1,hN=0.03,hDR=0.03,show=true,M=4,hm=0,f=12,non_func=["D","N","O"])
    M2=Int(M*(M+1)/2)
    wm=ones(M2)
    if M==5
        wf0=[1,
        1-h*s,
        1-hN*s,
        1-sigma,
        1-h*s,
        1-s,
        1-s,
        (1-sigma)*(1-hDR*s),
        1-s,
        1-s,
        (1-sigma)*(1-hN*s),
        1-s,
        (1-sigma)^2,
        (1-sigma)*(1-hDR*s),
        1-s
        ]
        wfth=["1",
        "1-hs",
        "1-hN*s",
        "1-sigma",
        "1-h*s",
        "1-s",
        "1-s",
        "(1- sigma)(1-hDRs)",
        "1-s",
        "1-s",
        "(1-sigma)(1-hN*s)",
        "1-s",
        "(1-sigma)^2",
        "(1-sigma)(1-hDR*s)",
        "1-s"
        ]
        namesG=["WW","WD","WN","WR","WO","DD","DN","DR","DO","NN","NR","NO", "RR","RO","OO"]
        
     end
    if M==4
        wf0=[1,
        1-h*s,
        1-hN*s,
        1-sigma,
        1-s,
        1-s,
        (1-sigma)*(1-hDR*s),
        1-s,
        (1-sigma)*(1-hN*s),
        (1-sigma)^2,
        ]
        wfth=["1",
        "1-h*s",
        "1-h_N*s",
        "1-sigma",
        "1-s",
        "1-s",
        "(1-sigma)(1-hDR*s)",
        "1-s",
        "(1-sigma)(1-hN*sN)",
        "(1-sigma)^2",
        ]
        namesG=["WW","WD","WN","WR","DD","DN","DR","NN","NR","RR"]
                
    end
    namesF=["Males","Females","Formula (female)"]
    wf=ones(M2);wf[wf0.<=0] .=0
    di=occursin.("D",namesG);wm[di].=1-hm
    
    ff=ones(M2,M2).*f
    for j in 1:M2 for i in 1:M2 ff[i,j]=wf0[i]*wm[j]*f;end;end
    if show 
        pretty_table([wm wf0 wfth ],header=namesF,tf=tf_borderless,row_labels=namesG,alignment=:l)
    end
    return wm,wf,ff
end

#Integrated suppression area calculation for a population count output
IntegralCum=function(;maxgen=400,dat,n)
    method = TrapezoidalRule()
    arr=[]
    for t in 2:maxgen
        problem=SampledIntegralProblem((n/2 .-dat[1:t])./(n/2), 1:t)
        push!(arr,solve(problem, method).u)
    end
    return arr
end

#Duration of protection calculation based on population count data. Returns number of generations when population is reduced to <=p pf its original size
TimePerc=function(n;maxt=300,perc=0.5)
    n0=n[1]
    tt=filter(x->n[x]<=n0*perc,1:maxt)
    return first(tt),last(tt),last(tt)-first(tt)
end